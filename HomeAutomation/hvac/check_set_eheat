#!/bin/bash
#designed to run with the output of the procFurnace program as our command line.
#Look at the various temperatures and, then use the TESTVAL condition to either
#set or reset Relay #5 on the modtronix board, which presumeably is the Y wire
#from the thermostat to the furnace/heat-pump
if [ $# -lt 8 ] 
then
    echo "check_set_eheat missing command line arguments. need at least 8. got $#" 1>&2
    exit 1
fi
if (( ("$1" < 0) || ( "$1" > 50) )); then
    echo "MinTemp cannot be $1. Must be in the range 0 to 50." 1>&2
    exit 2
fi

#the stdout of combine_inputs is such that our $6 and $7 are two outside temperature sensors
#in Fahrenheit. Have to send the strings to bc to do floating point compare
#
# setting date  time                    in    out  airport    A1    A2    A3    A4
# $1 $2         $3       $4             $5    $6      $7      $8    $9    $10  $11
# 25 2012/07/10 19:33:52 Temperature(F) 75.54 76.55   92   3.396 77.34 73.83 -459.7
#
#  $1 is the heat pump set point--outside temp below this, disable heat pump
#  $6 is from the USB thermometer, metal tip on the longer cable
#  $7 is Sandpoint airport from forecast.weather.gov
#  $8, $9, $10, $11 come from procFurnace.cpp processing, which, in turn,
#  has to match how the furnace controller is wired

# use the bc program because we have non-integers that bash won't compare for us.

#function to convert floating point input temperature to integer, and restrict
#to range. Any number outside that range is assumed to be invalid
#and is set to $4 so it won't be used.

function validateAndIntTemp()
{  #overwrites first argument with second argument validated as a temperature w.r.t. arg 3
	local __resultvar=$1
   #not sure why bc behaves this way... the v/1 at the end is only way to get it to truncate
        eval $__resultvar='$(echo "scale=5;v=$2;if (v<$3) v=$4; if (v > 0) v+=0.5 else v-=0.5;scale=0; v/1;" | bc -q)'
}

#
#Edit me here to pick off the desired temperatures from the command line
#Any temperature outside the range of -20 to 120 should be ignored as bad data
#
# What algorithm to use to decide? 
# If any of the validated temperatures $6, $7 or $8 are below $1, then disable heat pump
#
#assigns usbOutside to valided 6th argument
validateAndIntTemp usbOutside $6 -40 120		#trust to -40 on USB thermo per its specs	
validateAndIntTemp airportReported $7 -60 120	#trust NOAA.gov to -60
validateAndIntTemp heatpumpOutside $8 -20 120	#trust Honeywell outside sensor to -20, per its specs

MINT=$usbOutside
if (( $airportReported < $MINT )) 
then
	MINT=$airportReported
fi
if (( $heatpumpOutside < $MINT ))
then
	MINT=$heatpumpOutside
fi

if (( $MINT == 120 ))
then
	exit 1
fi
# echo "usbOutside= $usbOutside, airportReported= $airportReported, heatpumpOutside= $heatpumpOutside" 1>&2

if (( $MINT < $1 ))
then
	#send disable Y wire (heat pump) command to board. 
        #date 1>&2
        #echo "Set EHEAT ON with MIN=$MIN and \$1= $1" 1>&2
	curl --max-time 30 --silent $FURNACE_LOGIN http://$FURNACE_IP/nothing?xr5=1 > /dev/null 2>&1
else
	if (( $MINT > $1 ))
	then
 		#date 1>&2
 		#echo "Set EHEAT OFF with MINT=$MINT and UPPER=$UPPER" 1>&2
		#send enable Y wire (heat pump) command to board
		curl --max-time 30 --silent $FURNACE_LOGIN http://$FURNACE_IP/nothing?xr5=0 > /dev/null 2>&1
        fi
fi
#else if $MINT == $1 then do nothing--hysteresis
